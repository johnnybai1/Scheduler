import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.PriorityQueue;

/**
 * Intended to run after the Scheduler program has run, since it uses information
 * calculated by Scheduler. This program will pause every time a context switch occurs.
 * For scheduling stats, refer to output generated by Scheduler.
 */

public class SchedulerAnimation extends JFrame implements KeyListener {

    static final int WIDTH = 1920 / 2;
    static final int HEIGHT = 1080;
    static final int UPDATES_PER_SEC = 60;  // number of updates per second
    static final long UPDATE_PERIOD_NSEC = 1000000000L / UPDATES_PER_SEC;  // nanoseconds
    static final Color[] COLORS = new Color[] {
            Color.BLUE, Color.RED, Color.CYAN,
            Color.MAGENTA, Color.ORANGE,
            Color.YELLOW, Color.PINK, Color.GREEN};
    // 8 Colors to support up to 8 processes (for animation only)

    static final ArrayList<Scheduler.SchedulerState> history = Scheduler.getHistory();
    static AbstractStrategy strategy;

    Container cp;

    JScrollPane table;
    JLabel timer;
    QueueDisplay queues; // for the queues
    Timeline timeline; // displaying CPU history

    static int time = 0; // current time, use this to access ArrayList<Scheduler>

    private boolean PAUSED = true;

    // Adding all the necessary components to our Frame
    public SchedulerAnimation(Scheduler scheduler) {
        strategy = scheduler.getStrategy();

        cp = getContentPane();
        cp.setLayout(new BorderLayout());

        table = new JScrollPane(new ProcessTable().processTable);
        table.setPreferredSize(new Dimension(WIDTH, 140));
        cp.add(table, BorderLayout.NORTH);

        timer = new JLabel("0");
        timer.setFont(new Font("Serif", Font.BOLD, 50));
        timer.setHorizontalAlignment(JLabel.CENTER);
        timer.setVerticalAlignment(JLabel.BOTTOM);
        cp.add(timer, BorderLayout.EAST);

        queues = new QueueDisplay(strategy.getNumStrategies());
        cp.add(queues, BorderLayout.CENTER);

        timeline = new Timeline();
        timeline.setPreferredSize(new Dimension(WIDTH * 8, 200));

        JScrollPane scroll = new JScrollPane(timeline);
        scroll.setPreferredSize(new Dimension(WIDTH, 200));

        cp.add(scroll, BorderLayout.SOUTH);

        cp.revalidate();
        cp.repaint();

        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setTitle("Scheduling");
        setSize(WIDTH, HEIGHT);
        addKeyListener(this);
        setResizable(false);
        setVisible(true);
        setFocusable(true);
        requestFocus();

        start();
    }

    public void start() {
        Thread thread = new Thread() {
            @Override
            public void run() {
                loop();
            }
        };
        thread.start();
    }

    @Override
    public void keyTyped(KeyEvent e) {
        // Do nothing
    }

    /**
     * Press "1" or "SPACEBAR" to pause/unpause
     */
    @Override
    public void keyPressed(KeyEvent e) {
        switch (e.getKeyChar()) {
            case KeyEvent.VK_1: {
                PAUSED = !PAUSED;
            }
            case KeyEvent.VK_SPACE: {
                PAUSED = !PAUSED;
            }
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
        // Do nothing
    }

    /**
     * The thread that governs this loop was obtained from
     * http://www.java-gaming.org/index.php?topic=24220.0
     */
    public void loop() {
        long start, elapsed, remain;   // in ms
        // Loop
        int count = 0;
        while (time < history.size() - 1) {
            if (PAUSED) {
                System.console();
            } else {
                start = System.nanoTime();
                // Refresh the display
                timeline.update();
                timeline.repaint();
                // Delay timer to provide the necessary delay to meet the target rate
                elapsed = System.nanoTime() - start;
                count++;
                if (count % 60 == 0) {
                    // Note that since UPDATES_PER_SECOND = 60, count % 60 == 0
                    // is needed to increment the timer every second. To speed
                    // up the timer, can simply decrease 60 to a smaller amount.
                    count = 0;
                    time++;
                    queues.update();
                    queues.repaint();
                    PAUSED = timeline.pauseTimes[time];
                    timer.setText(Integer.toString(time));
                }
                remain = (UPDATE_PERIOD_NSEC - elapsed) / 1000000;  // in milliseconds
                if (remain < 17) remain = 17;   // set a minimum
                try {
                    // Provides the necessary delay
                    Thread.sleep(remain);
                } catch (InterruptedException ex) {
                }
            }
        }
    }


    class ProcessTable extends JPanel {

        JTable processTable;

        public ProcessTable() {
            Process[] table = history.get(0).getTable();
            Object columns[] = {"PID", "ARRIVAL", "PRIORITY", "BURSTS"};
            Object rows[][] = new Object[table.length][4];
            for (int i = 0; i < table.length; i++) {
                rows[i][0] = table[i].getPID();
                rows[i][1] = table[i].getArrivalTime();
                rows[i][2] = table[i].getPriority();
                rows[i][3] = table[i].burstToString();
            }
            processTable = new JTable(rows, columns);

            add(processTable);
            setVisible(true);
        }

    }

    class Timeline extends JPanel {

        private int y1;
        private int widthUnit;
        // increase width to increase number of context switches supported
        private int width = SchedulerAnimation.WIDTH * 8; // make 8 higher if processes begin to overlap
        ProcessBlock[] run;
        boolean[] pauseTimes;


        public Timeline() {
            setPreferredSize(new Dimension(1920, 100));
            y1 = 54;
            widthUnit = 60;
            buildRun();
        }

        /**
         * To visualize the simulation, we do not calculate anything in real time.
         * The scheduler runs, creating snapshots of the states of the scheduler
         * at each time unit. We use these snapshots to provide the visualization.
         */
        public void buildRun() {
            int tracker = 0; // to organize offsets
            run = new ProcessBlock[history.size()];
            pauseTimes = new boolean[history.size()];
            for (int i = 0; i < history.size(); i++) {
                pauseTimes[i] = true; // we pause whenever there's a context switch
                Process CPU = history.get(i).getCPU();
                if (CPU == null) {
                    run[i] = new ProcessBlock(tracker * widthUnit, y1, -1, 1, Color.GRAY);
                }
                else {
                    run[i] = new ProcessBlock(tracker * widthUnit, y1, CPU.getPID(),
                            CPU.getCurrentRuntime() + 1, COLORS[CPU.getPID()]);
                }
                // To merge process blocks:
                if (i > 0 && run[i].PID == run[i-1].PID) {
                    run[i].x = run[i-1].x; // make current block the last block
                    run[i].count = run[i-1].count + 1; // increment block's counter
                    tracker--; // decrement tracker since we increment it later
                    // we don't actually want to decrement it here
                    pauseTimes[i] = false; // No pause since no context switch
                }
                tracker++;
                run[i].width = widthUnit;
            }
        }

        /**
         * The run[] array stores the processes scheduled for the CPU.
         * The current process on the CPU is dictated by run[time].
         */
        public void update() {
            run[SchedulerAnimation.time].width = 60; // this makes the process block visible

        }

        /**
         * Draw our timeline. At each time unit, draw the appropriate blocks.
         */
        @Override
        public void paintComponent(Graphics g) {
            Graphics2D g2d = (Graphics2D) g;
            super.paintComponent(g2d);
            // Drawing the timeline
            for (int i = 0; i <= width; i += 60) {
                g2d.drawLine(i, y1, i, y1 + 50);
            }
            g2d.drawLine(0, y1 + 50 / 2, width, y1 + 50 / 2);
            // drawing the process blocks
            for (int i = 0; i <= SchedulerAnimation.time; i++) {
                run[i].draw(g2d);
            }
        }

    }

    class QueueDisplay extends JPanel {

        int numReadyQueues;
        int[] yLocations;
        ProcessBlock[] processes;

        public QueueDisplay() {
            this(1);
        }

        public QueueDisplay(int numReadyQueues) {
            this.numReadyQueues = numReadyQueues;
            yLocations = new int[numReadyQueues + 1];
            setPreferredSize(new Dimension(SchedulerAnimation.WIDTH, 400));
            int spacing = 400 / (numReadyQueues + 1);
            int count = 0;
            for (int i = 0; i < numReadyQueues + 1; i++) {
                yLocations[count] = i * spacing;
                count++;
            }

            Process[] table = history.get(0).getTable();
            processes = new ProcessBlock[table.length];
            // Effectively hidden at the beginning
            int startX = -200;
            int startY = -200;
            for (int i = 0; i < table.length; i++) {
                processes[i] = new ProcessBlock(startX, startY, i, 0, COLORS[i]);
            }
        }

        /**
         * Only deal in discretes with queues. E.g. update when time is updated
         */
        public void update() {
            int startX = 125;
            int width = 50;
            // Get the state of the ready queue(s)
            ArrayList<PriorityQueue<Process>> queues = history.get(SchedulerAnimation.time).getReadyQueue();
            // Set all processes to invisible
            for (int i = 0; i < processes.length; i++) {
                processes[i].setInvisible();
            }
            int size = 1;
            // Only MLFQ has multiple ready queues.
            if (SchedulerAnimation.strategy instanceof SimpleMLFQ) {
                size = queues.size();
            }
            // Iterate through each queue
            for (int i = 0; i < size; i++) {
                int count = 0;
                PriorityQueue<Process> ready = queues.get(i);
                Iterator<Process> itr = ready.iterator();
                // Iterate through each process in the queue
                while (itr.hasNext()) {
                    Process next = itr.next();
                    int PID = next.getPID();
                    // Make them "visible" in the correct location
                    processes[PID].x = startX + (count * width);
                    processes[PID].y = yLocations[i + 1];
                    processes[PID].width = width;
                    processes[PID].count = next.getCurrentBurst();
                    count++;
                }
            }
            // Do the same thing for blocked list
            ArrayList<Process> blocked = history.get(SchedulerAnimation.time).getBlockedList();
            for (int i = 0; i < blocked.size(); i++) {
                Process curr = blocked.get(i);
                int PID = curr.getPID();
                processes[PID].x = startX + (i * width);
                processes[PID].y = yLocations[0];
                processes[PID].width = width;
                processes[PID].count = curr.getCurrentBurst();
            }
        }


        @Override
        public void paintComponent(Graphics g) {
            int[] quantums = history.get(SchedulerAnimation.time).getQuantums();
            super.paintComponent(g);
            for (int i = 1; i < yLocations.length; i++) {
                g.drawString("Ready Queue " + i + ": ", 20, 20 + yLocations[i]);
                g.drawString("Quantum " + quantums[i - 1], 20, 50 + yLocations[i]);
            }
            g.drawString("Blocked List: ", 20, 20 + yLocations[0]);
            for (int i = 0; i < processes.length; i++) {
                processes[i].draw(g);
            }
        }
    }

    class ProcessBlock {

        Color color;
        int x, y;
        int height, width;
        int PID, count;

        public ProcessBlock(int x, int y, int PID, int count, Color color) {
            this.x = x;
            this.y = y;
            this.PID = PID;
            height = 50;
            this.color = color;
            this.count = count;
        }

        public void setInvisible() {
            this.x = -200;
            this.y = -200;
        }

        public void draw(Graphics g2d) {
            g2d.setColor(color);
            g2d.fillRect(x, y, width, height);
            String label = "P" + PID;
            g2d.setColor(Color.BLACK);
            g2d.setFont(new Font("Serif", Font.BOLD, 20));
            if (PID == -1) {
                // Idle process
                g2d.drawString("IDLE", x + 5, y + 20);
            } else {
                // Actual process
                g2d.drawString(label, x + 5, y + 20);
            }
            // Draw label for "time"
            g2d.drawString(Integer.toString(count), x + 5, y + 40);
        }

        public void setWidth(int width) {
            this.width = width;
        }

        public int getWidth() {
            return width;
        }

    }

}
